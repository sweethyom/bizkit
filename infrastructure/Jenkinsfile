def develop() {
    return env.BRANCH_NAME == 'backend' && env.GITLAB_OBJECT_KIND == 'push'
}

def mr() {
    def isMRToBackendDevelop = env.GITLAB_OBJECT_KIND == 'merge_request' && env.GITLAB_OA_TARGET_BRANCH == 'backend'
    def isMROpen = env.GITLAB_OA_ACTION == 'open'
    def isMRUpdate = env.GITLAB_OA_ACTION == 'update'
    
    return isMRToBackendDevelop && (isMROpen || isMRUpdate)
}

def triggerType() {
    if (develop()) {
        return "PUSH"
    } else if (mr()) {
        return "MR ë³€ê²½"
    }
    return ""
}

def getEmoji(success) {
    return success ? 'âœ…' : 'â›”'
}

def updateGitOpsRepository(String gitopsFilePath, String dockerImageName) {
    withCredentials([usernamePassword(credentialsId: 'github-macnini-gitops-repo-credential',
                                        passwordVariable: 'GIT_PASSWORD',
                                        usernameVariable: 'GIT_USERNAME')]) {
        sh """
            rm -rf ${GITOPS_TEMP_DIR}
            mkdir -p ${GITOPS_TEMP_DIR}
            cd ${GITOPS_TEMP_DIR}
            
            git clone "https://\$GIT_USERNAME:\$GIT_PASSWORD@\${GITOPS_REPO#https://}"
            cd ${GITOPS_REPO_NAME}
            
            git config user.name "\$GIT_USERNAME"
            git config user.email "${GIT_COMMIT_EMAIL}"
            
            sed -i "s|image: ${DOCKER_HUB_USERNAME}/${dockerImageName}:[0-9]*|image: ${DOCKER_HUB_USERNAME}/${dockerImageName}:${env.BUILD_NUMBER}|g" ${gitopsFilePath}
            
            git add ${gitopsFilePath}
            git commit -m "Update ${dockerImageName} image tag to ${env.BUILD_NUMBER}"
            git push "https://\$GIT_USERNAME:\$GIT_PASSWORD@\${GITOPS_REPO#https://}"
            
            cd ../..
        """
    }
}

pipeline {
    agent { label 'master' }

    parameters {

        string(name: 'BACKEND_DIR', defaultValue: './backend', description: "Repository ë‚´ backend í”„ë¡œì íŠ¸ ìœ„ì¹˜")
        string(name: 'DOCKER_REGISTRY_URL', defaultValue: 'docker.io', description: 'Docker ë ˆì§€ìŠ¤íŠ¸ë¦¬ URL')
        string(name: 'DOCKER_HUB_USERNAME', defaultValue: 'duk9741', description: 'Docker Hub ì‚¬ìš©ìëª…')
        string(name: 'GITOPS_REPO', defaultValue: 'https://github.com/dukcode/macmini-gitops.git', description: 'GitOps ì €ì¥ì†Œ URL')
        string(name: 'GITOPS_REPO_NAME', defaultValue: 'macmini-gitops', description: 'GitOps ì €ì¥ì†Œ ì´ë¦„')
        string(name: 'GITOPS_TEMP_DIR', defaultValue: 'tmp_gitops', description: 'GitOps ì„ì‹œ ë””ë ‰í„°ë¦¬')
        string(name: 'GIT_COMMIT_EMAIL', defaultValue: 'jenkins@dukcode.org', description: 'Git ì»¤ë°‹ ì´ë©”ì¼')
        string(name: 'IMAGE_REGISTRY_ACCOUNT', defaultValue: 'duk9741', description: 'Docker ë ˆì§€ìŠ¤íŠ¸ë¦¬ ê³„ì •')

        string(name: 'API_DOCS_DOCKER_IMAGE_NAME',defaultValue: 'bizkit-api-docs', description: 'API ë¬¸ì„œ Docker ì´ë¯¸ì§€ ì´ë¦„')
        string(name: 'API_DOCS_GITOPS_FILE_PATH', defaultValue: 'bizkit/api-docs.yaml', description: 'API ë¬¸ì„œ GitOps ë©”ë‹ˆí˜ìŠ¤íŠ¸ ìœ„ì¹˜')
        string(name: 'API_DOCS_DOCKERFILE_PATH', defaultValue: 'infrastructure/Dockerfile.api-docs',  description: 'API ë¬¸ì„œ Dockerfile ê²½ë¡œ')

        string(name: 'API_DOCKER_IMAGE_NAME',defaultValue: 'bizkit-api', description: 'API ë¬¸ì„œ Docker ì´ë¯¸ì§€ ì´ë¦„')
        string(name: 'API_GITOPS_FILE_PATH', defaultValue: 'bizkit/api.yaml', description: 'API ë¬¸ì„œ GitOps ë©”ë‹ˆí˜ìŠ¤íŠ¸ ìœ„ì¹˜')
        string(name: 'API_DOCKERFILE_PATH', defaultValue: 'infrastructure/Dockerfile.api',  description: 'API ë¬¸ì„œ Dockerfile ê²½ë¡œ')

        string(name: 'SONAR_PROJECT_KEY', defaultValue: 'com.ssafy:bizkit', description: 'SonarQube í”„ë¡œì íŠ¸ í‚¤')
    }

    stages {

        stage('Trigger Notification') {
            steps {
                script {
                    def authorName = env.GITLAB_USER_NAME ?: 'N/A'

                    def triggerType = develop() ? "ğŸš€ **PUSH ì´ë²¤íŠ¸**" : "ğŸ”„ **MR ì´ë²¤íŠ¸**"
                    
                    def branchInfo = develop() ? 
                        "â–«ï¸ ë¸Œëœì¹˜: `${env.BRANCH_NAME}`" : 
                        "â–«ï¸ ì†ŒìŠ¤ ë¸Œëœì¹˜: `${env.GITLAB_OA_SOURCE_BRANCH}`\nâ–«ï¸ íƒ€ê²Ÿ ë¸Œëœì¹˜: `${env.GITLAB_OA_TARGET_BRANCH}`"
                    
                    def commitInfo = ""
                    if (develop()) {
                        commitInfo = """
                        |â–«ï¸ ì‘ì„±ì: ${authorName}
                        """.stripMargin().trim()
                    } else {
                        def mrTitle = env.GITLAB_OA_TITLE ?: 'N/A'
                        commitInfo = """
                        |â–«ï¸ MR ë§í¬: [${mrTitle}](${env.GITLAB_OA_URL})
                        |â–«ï¸ MR ì‘ì„±ì: ${authorName}
                        """.stripMargin()
                    }

                    def message = """
                    |### ${triggerType} ê°ì§€ë¨
                    |
                    |**âœ”ï¸ ì‘ì—…ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤** 
                    |
                    |**ğŸ“Œ ê¸°ë³¸ ì •ë³´**
                    |${branchInfo}
                    |${commitInfo}
                    |
                    |**ğŸ“ ì‹¤í–‰ ì •ë³´**
                    |â–«ï¸ [ë¹Œë“œ ì‹¤í–‰ ë³´ê¸°](${env.BUILD_URL})
                    |â–«ï¸ ì‘ì—… ID: `${env.BUILD_ID}`
                    """.stripMargin().replaceAll(/\n\s+\|/, '\n').trim()

                    mattermostSend(
                        color: '#00AAFF',
                        message: message
                    )
                }
            }
        }

        stage('Check Lint') {
            steps {
                sh "cd ${params.BACKEND_DIR} && ./gradlew clean spotlessCheck"
            }
            post {
                always {
                    script {
                        env.LINT_CHECK = getEmoji(currentBuild.currentResult == 'SUCCESS')
                    }
                }
            }
        }
        
        stage('Build') {
            steps {
                sh "cd ${params.BACKEND_DIR} && ./gradlew build -x test -x spotlessCheck"
                stash includes: 'backend/core/core-api/build/libs/core-api-0.0.1-SNAPSHOT.jar', name: 'api-jar-stash'
            }
            post {
                always {
                    script {
                        env.BUILD_STATUS = getEmoji(currentBuild.currentResult == 'SUCCESS')
                    }
                }
            }
        }

        stage('Test') {
            steps {
                sh "cd ${params.BACKEND_DIR} && ./gradlew test"
            }
            post {
                always {
                    script {
                        env.TEST_STATUS = getEmoji(currentBuild.currentResult == 'SUCCESS')
                    }
                }
            }
        }

        stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('dukcode-sonarqube') {
                    sh "cd ${params.BACKEND_DIR} && ./gradlew sonar"
                    
                    // SonarQube í”„ë¡œì íŠ¸ URL ì €ì¥
                    script {
                        def sonarServerUrl = env.SONAR_HOST_URL
                        env.SONARQUBE_PROJECT_URL = "${sonarServerUrl}/dashboard?id=${params.SONAR_PROJECT_KEY}"
                    }
                }
            }
            post {
                always {
                    script {
                        env.SONARQUBE_ANALYSIS_STATUS = getEmoji(currentBuild.currentResult == 'SUCCESS')
                    }
                }
            }
        }

        stage('Check Quality Gate') {
            steps {
                script {
                    // Wait for SonarQube Quality Gate and get results
                    def qg = waitForQualityGate()
                    env.SONARQUBE_QG_STATUS = qg.status
                    
                    // í€„ë¦¬í‹° ê²Œì´íŠ¸ì˜ ì„¸ë¶€ ë‚´ìš© ì €ì¥
                    if (qg.status != 'OK') {
                        // ì¡°ê±´ë“¤ì„ íŒŒì‹±í•˜ì—¬ ì‹¤íŒ¨í•œ ì¡°ê±´ ì •ë³´ ì €ì¥
                        def failedConditions = []
                        qg.conditions.each { condition ->
                            if (condition.status != 'OK') {
                                failedConditions.add("${condition.metricKey}: ${condition.actualValue} (ì„ê³„ê°’: ${condition.errorThreshold})")
                            }
                        }
                        env.SONARQUBE_QG_DETAILS = failedConditions.join(', ')
                    }
                }
            }
            post {
                always {
                    script {
                        // Set emoji based on Quality Gate status
                        env.SONARQUBE_QG_ANALYSIS_STATUS = getEmoji(env.SONARQUBE_QG_STATUS == 'OK')
                    }
                }
            }
        }

        stage('API Documentation') {
            steps {
                sh """
                cd ${params.BACKEND_DIR} && ./gradlew asciidoctor
                """
                stash includes: 'backend/support/restdocs/build/docs/asciidoc/index.html', name: 'api-docs-stash'
            }
            post {
                always {
                    script {
                        env.API_DOCS_STATUS = getEmoji(currentBuild.currentResult == 'SUCCESS')
                    }
                }
            }
        }

        stage('API Docs: Build and Tag Docker Image with Kaniko') {
            when {
                beforeAgent true
                expression { develop() }
            }
            agent {
                kubernetes {
                    yaml """
kind: Pod
spec:
  containers:
  - name: kaniko
    image: gcr.io/kaniko-project/executor:debug
    imagePullPolicy: Always
    command:
    - sleep
    args:
    - 9999999
    volumeMounts:
      - name: jenkins-docker-cfg
        mountPath: /kaniko/.docker
  volumes:
  - name: jenkins-docker-cfg
    projected:
      sources:
      - secret:
          name: dockerhub-credentials
          items:
            - key: .dockerconfigjson
              path: config.json
"""
                }
            }
            steps {
                container(name: 'kaniko', shell: '/busybox/sh') {
                    script {
                        unstash 'api-docs-stash'
                        sh """
                        /kaniko/executor \\
                            --context `pwd` \\
                            --dockerfile=${API_DOCS_DOCKERFILE_PATH} \\
                            --destination=${DOCKER_REGISTRY_URL}/${DOCKER_HUB_USERNAME}/${API_DOCS_DOCKER_IMAGE_NAME}:${env.BUILD_NUMBER} \\
                            --insecure \\
                            --skip-tls-verify \\
                            --cache=true \\
                            --cache-dir=/workspace/cache
                        """
                    }
                }
            }
            post {
                always {
                    script {
                        env.API_DOCS_IMAGE_BUILD_PUSH_STATUS = getEmoji(currentBuild.currentResult == 'SUCCESS')
                    }
                }
            }
        }

        stage('API: Build and Tag Docker Image with Kaniko') {
            when {
                beforeAgent true
                expression { develop() }
            }
            agent {
                kubernetes {
                    yaml """
kind: Pod
spec:
  containers:
  - name: kaniko
    image: gcr.io/kaniko-project/executor:debug
    imagePullPolicy: Always
    command:
    - sleep
    args:
    - 9999999
    volumeMounts:
      - name: jenkins-docker-cfg
        mountPath: /kaniko/.docker
  volumes:
  - name: jenkins-docker-cfg
    projected:
      sources:
      - secret:
          name: dockerhub-credentials
          items:
            - key: .dockerconfigjson
              path: config.json
"""
                }
            }
            steps {
                container(name: 'kaniko', shell: '/busybox/sh') {
                    script {
                        unstash 'api-jar-stash'
                        sh """
                        /kaniko/executor \\
                            --context `pwd` \\
                            --dockerfile=${API_DOCKERFILE_PATH} \\
                            --destination=${DOCKER_REGISTRY_URL}/${DOCKER_HUB_USERNAME}/${API_DOCKER_IMAGE_NAME}:${env.BUILD_NUMBER} \\
                            --insecure \\
                            --skip-tls-verify \\
                            --cache=true \\
                            --cache-dir=/workspace/cache
                        """
                    }
                }
            }
            post {
                always {
                    script {
                        env.API_IMAGE_BUILD_PUSH_STATUS = getEmoji(currentBuild.currentResult == 'SUCCESS')
                    }
                }
            }
        }
        
        stage('Update GitOps Repository') {
            when { expression { develop() } }
            steps {
                script {
                    updateGitOpsRepository(API_DOCS_GITOPS_FILE_PATH, API_DOCS_DOCKER_IMAGE_NAME)
                    updateGitOpsRepository(API_GITOPS_FILE_PATH, API_DOCKER_IMAGE_NAME)
                }
            }
            post {
                always {
                    script {
                        env.COMMIT_TO_GITOPS_REPO_STATUS = getEmoji(currentBuild.currentResult == 'SUCCESS')
                    }
                }
            }
        }

    }
    
post {
    always {
        script {
            def resultEmoji = currentBuild.currentResult == 'SUCCESS' ? '## ğŸ‰ *ë¹Œë“œ ì„±ê³µ*' : '## ğŸ”¥ *ë¹Œë“œ ì‹¤íŒ¨*'
            def triggerEmoji = develop() ? 'ğŸ“Œ PUSH' : 'ğŸ”„ MR ë³€ê²½'
            def duration = currentBuild.durationString.replace(' and counting', '')
            
            def message = """
            |${resultEmoji}
            |*ë¹Œë“œ ë²ˆí˜¸*: #${env.BUILD_NUMBER}
            |*íŠ¸ë¦¬ê±°*: ${triggerEmoji}
            |*ì†Œìš” ì‹œê°„*: ${duration}

            |\n**ğŸ” ë¹Œë“œ ìƒíƒœ ìš”ì•½**
            |â–«ï¸ ë¦°íŠ¸ ê²€ì‚¬: ${env.LINT_CHECK ?: 'â”'}  
            |â–«ï¸ ë¹Œë“œ ê²°ê³¼: ${env.BUILD_STATUS ?: 'â”'}  
            |â–«ï¸ í…ŒìŠ¤íŠ¸ ê²°ê³¼: ${env.TEST_STATUS ?: 'â”'}  

            |\n**ğŸ›  ì½”ë“œ í’ˆì§ˆ ë¶„ì„**
            |â–«ï¸ ì†Œë‚˜íë¸Œ ë¶„ì„: ${env.SONARQUBE_ANALYSIS_STATUS ?: 'â”'}  
            |â–«ï¸ í€„ë¦¬í‹° ê²Œì´íŠ¸: ${env.SONARQUBE_QG_ANALYSIS_STATUS ?: 'â”'} ${env.SONARQUBE_QG_STATUS ? "(ìƒíƒœ: ${env.SONARQUBE_QG_STATUS})" : ""}
            |${env.SONARQUBE_PROJECT_URL ? "â–«ï¸ [ì†Œë‚˜íë¸Œ ëŒ€ì‹œë³´ë“œ ë³´ê¸°](${env.SONARQUBE_PROJECT_URL})" : ""}
            ${env.SONARQUBE_QG_DETAILS ? "|âš ï¸ *ì‹¤íŒ¨ í•­ëª©*: ${env.SONARQUBE_QG_DETAILS}" : ""}

            |\n**ğŸ“š API ë¬¸ì„œí™”**
            |â–«ï¸ ë¬¸ì„œ ìƒì„±: ${env.API_DOCS_STATUS ?: 'â”'} 

            ${develop() ? """|
            |\n**ğŸ³ ì»¨í…Œì´ë„ˆ ì´ë¯¸ì§€ ë¹Œë“œ&í‘¸ì‹œ**
            |â–«ï¸ API DOCS ì´ë¯¸ì§€ ë¹Œë“œ&í‘¸ì‹œ: ${env.API_DOCS_IMAGE_BUILD_PUSH_STATUS ?: 'â”'}
            |â–«ï¸ API ì´ë¯¸ì§€ ë¹Œë“œ&í‘¸ì‹œ: ${env.API_IMAGE_BUILD_PUSH_STATUS ?: 'â”'}
            |â–«ï¸ GitOps ì—…ë°ì´íŠ¸: ${env.COMMIT_TO_GITOPS_REPO_STATUS ?: 'â”'}
            """ : ""}

            ${develop() ? """|
            |\n**ğŸ“¦ ì•„í‹°íŒ©íŠ¸ ì •ë³´**
            |â–«ï¸ API Docs Docker Image: ${DOCKER_HUB_USERNAME}/${API_DOCS_DOCKER_IMAGE_NAME}:${env.BUILD_NUMBER}
            |â–«ï¸ API Docker Image: ${DOCKER_HUB_USERNAME}/${API_DOCKER_IMAGE_NAME}:${env.BUILD_NUMBER}
            """ : ""}
            """

            message = message.replaceAll(/\n\s+\|/, '\n').trim()

            mattermostSend(
                color: currentBuild.currentResult == 'SUCCESS' ? '#00CC00' : '#FF3300',
                message: message
            )
        }
    }
}
}